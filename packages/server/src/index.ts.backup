import express from 'express';
import cors from 'cors';
import multer from 'multer';
import { v4 as uuid } from 'uuid';
import Tesseract from 'tesseract.js';
import fs from 'fs';
import path from 'path';
import sharp from 'sharp';
import { PDFDocument } from 'pdf-lib';
// import pdf from 'pdf-parse';
import * as pdfjsLib from 'pdfjs-dist/legacy/build/pdf.js';
import { createCanvas } from 'canvas';
import {
  LIMITS,
  createEventSimilarity,
  createTagSimilarity,
  combineSimilarities,
  BoardService,
} from '@insight-box/core';
import type {
  CardDetailOutputs,
  CardSummary,
  DepartmentRatio,
  EventMeta,
  MarketplaceCard,
  MarketplaceOutputs,
  ReactionSummary,
  SettingsRolesInputs,
  ShareModalInputs,
  ShareModalOutputs,
  Tag,
  TemplateModalInputs,
  TemplateModalOutputs,
  ViewState,
} from '@insight-box/core';

const app = express();
app.use(cors());
app.use(express.json({ limit: '10mb' }));

// ファイルアップロード用の設定
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(process.cwd(), 'uploads');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueName = `${Date.now()}-${Math.random().toString(36).slice(2)}-${file.originalname}`;
    cb(null, uniqueName);
  }
});

const upload = multer({ 
  storage,
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB制限
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf', 'text/plain'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('サポートされていないファイル形式です'));
    }
  }
});

// 静的ファイル配信
app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));

const PORT = process.env.PORT ?? 5178;

interface CardRecord {
  id: string;
  detail: CardDetailOutputs;
  summary: CardSummary;
  reactions: ReactionSummary;
  timeseries: Array<{ date: string; views: number; comments: number; likes: number }>;
  audience: DepartmentRatio[];
}

const users = [
  { id: 'user-ryo', name: 'Ryo Tanamiki', role: 'visitor' as const },
  { id: 'user-ami', name: 'Ami Sato', role: 'member' as const },
  { id: 'user-admin', name: 'Admin Imai', role: 'admin' as const },
];

// イベントストア（メモリ内）
const eventStore: Map<string, EventMeta> = new Map();

// 初期イベントデータ
const initialEvents: EventMeta[] = [
  {
    id: 'event-2025-tokyo',
    name: '展示会 2025 TOKYO',
    startDate: '2025-02-12',
    endDate: '2025-02-15',
    location: 'Tokyo Big Sight',
  },
  {
    id: 'event-medtech',
    name: 'MedTech Summit',
    startDate: '2025-03-05',
    endDate: '2025-03-07',
    location: 'Osaka',
  },
];

// 初期イベントをストアに追加
initialEvents.forEach(event => {
  eventStore.set(event.id, event);
});

// イベント一覧を取得する関数
function getEvents(): EventMeta[] {
  return Array.from(eventStore.values());
}

const sampleTags: Tag[] = [
  { id: '3d-printing', label: '3Dプリンティング' },
  { id: 'medical', label: '医療' },
  { id: 'robotics', label: 'ロボティクス' },
  { id: 'ai', label: 'AI' },
  { id: 'event2025', label: '展示会2025' },
];

interface CardParams {
  cardId?: string;
  title: string;
  companyName?: string;
  eventId?: string;
  authorId: string;
  ocrText: string;
  tags: Tag[];
  memo?: string;
}

function createCardRecord(params: CardParams): CardRecord {
  const nowIso = new Date().toISOString();
  const event = params.eventId ? getEvents().find((e) => e.id === params.eventId) : undefined;
  const author = users.find((u) => u.id === params.authorId) ?? users[0];
  const cardId = params.cardId ?? uuid();
  const detail: CardDetailOutputs = {
    header: {
      title: params.title,
      companyName: params.companyName,
      event,
      author,
      createdAt: nowIso,
      updatedAt: nowIso,
      priority: 2,
    },
    body: {
      ocr: {
        text: params.ocrText,
        updatedAt: nowIso,
      },
      sourceFiles: [
        {
          id: `${cardId}-file`,
          filename: `${cardId}.jpg`,
          mimeType: 'image/jpeg',
          bytes: 2048,
        },
      ],
      highlights: params.memo ? [params.memo] : [],
      tags: params.tags,
    },
    sidebar: {
      relatedCards: [],
      collections: [],
      history: [
        {
          action: 'created',
          actor: author,
          at: nowIso,
          details: 'カードを作成',
        },
      ],
      reactions: {
        views: Math.floor(Math.random() * 200) + 20,
        comments: Math.floor(Math.random() * 10),
        likes: Math.floor(Math.random() * 15),
      },
    },
    state: 'success',
  };

  const summary: CardSummary = {
    id: cardId,
    title: detail.header.title,
    status: 'ready',
    thumbnailUrl: detail.body.sourceFiles[0]?.filename ? `/assets/${detail.body.sourceFiles[0].filename}` : undefined,
    eventId: detail.header.event?.id,
    tags: detail.body.tags,
    createdAt: detail.header.createdAt,
    createdBy: detail.header.author,
  };

  const timeseries = Array.from({ length: 7 }, (_, idx) => {
    const date = new Date();
    date.setDate(date.getDate() - (6 - idx));
    return {
      date: date.toISOString().slice(0, 10),
      views: Math.floor(Math.random() * 40) + 10,
      comments: Math.floor(Math.random() * 5),
      likes: Math.floor(Math.random() * 6),
    };
  });

  const audience: DepartmentRatio[] = [
    { department: '営業', ratio: 0.35 },
    { department: '企画', ratio: 0.25 },
    { department: '開発', ratio: 0.2 },
    { department: 'その他', ratio: 0.2 },
  ];

  return {
    id: cardId,
    detail,
    summary,
    reactions: detail.sidebar.reactions,
    timeseries,
    audience,
  };
}

const cardStore: Map<string, CardRecord> = new Map();

function seedData(): void {
  const demoCards: CardRecord[] = [
    createCardRecord({
      title: '次世代3Dプリンタ',
      companyName: 'XYZ Additive',
      eventId: 'event-2025-tokyo',
      authorId: 'user-ryo',
      ocrText: '高精度で医療用パーツを短時間で製造可能。',
      tags: [sampleTags[0], sampleTags[1], sampleTags[4]],
      memo: 'サンプル展示あり',
    }),
    createCardRecord({
      title: 'AI診断プラットフォーム',
      companyName: 'MedScope',
      eventId: 'event-medtech',
      authorId: 'user-ami',
      ocrText: 'AIを活用した術前診断、臨床導入数120件。',
      tags: [sampleTags[1], sampleTags[3]],
      memo: '導入事例を要チェック',
    }),
    createCardRecord({
      title: '協働ロボット T-Assist',
      companyName: 'Techno Assist',
      eventId: 'event-2025-tokyo',
      authorId: 'user-admin',
      ocrText: '軽量で持ち運びが容易、現場での実証実験中。',
      tags: [sampleTags[2], sampleTags[4]],
    }),
  ];

  demoCards.forEach((record) => {
    cardStore.set(record.id, record);
  });
}

seedData();

// テキストクリーニング関数（改行を保持）
// ポスト処理：ドメイン辞書と正規表現による拘束デコード
function applyPostProcessingCorrection(text: string): string {
  let correctedText = text;
  
  // 郵便番号の正規化（例：123-4567 → 123-4567）
  correctedText = correctedText.replace(/(\d{3})\s*-\s*(\d{4})/g, '$1-$2');
  
  // 日付の正規化（例：2025/1/1 → 2025/01/01）
  correctedText = correctedText.replace(/(\d{4})\/(\d{1,2})\/(\d{1,2})/g, (match, year, month, day) => {
    return `${year}/${month.padStart(2, '0')}/${day.padStart(2, '0')}`;
  });
  
  // 金額の正規化（例：1,000円 → 1,000円）
  correctedText = correctedText.replace(/(\d{1,3}(?:,\d{3})*)\s*円/g, '$1円');
  
  // 電話番号の正規化（例：03-1234-5678 → 03-1234-5678）
  correctedText = correctedText.replace(/(\d{2,4})\s*-\s*(\d{4})\s*-\s*(\d{4})/g, '$1-$2-$3');
  
  // よくあるOCR誤りを修正（全角数字・英字を半角に）
  const commonCorrections = [
    { from: /[０-９]/g, to: (match: string) => String.fromCharCode(match.charCodeAt(0) - 0xFF10 + 0x30) },
    { from: /[Ａ-Ｚ]/g, to: (match: string) => String.fromCharCode(match.charCodeAt(0) - 0xFF21 + 0x41) },
    { from: /[ａ-ｚ]/g, to: (match: string) => String.fromCharCode(match.charCodeAt(0) - 0xFF41 + 0x61) },
  ];
  
  for (const correction of commonCorrections) {
    correctedText = correctedText.replace(correction.from, correction.to as any);
  }
  
  return correctedText;
}

// 文書構造を認識して適切な改行を保持する関数
function preserveDocumentStructure(text: string): string {
  return text
    // 見出しパターンを認識（数字. で始まる行）
    .replace(/^(\s*)(\d+\.\s*[^\n]+)/gm, '$1$2\n')
    // サブ見出しパターンを認識（数字.数字 で始まる行）
    .replace(/^(\s*)(\d+\.\d+\s*[^\n]+)/gm, '$1$2\n')
    // 箇条書きパターンを認識（・、*、- で始まる行）
    .replace(/^(\s*)([・\*\-\u2022]\s*[^\n]+)/gm, '$1$2\n')
    // 詳細要件の箇条書き（* で始まる行）
    .replace(/^(\s*)(\*\s*[^\n]+)/gm, '$1$2\n')
    // 概要・詳細要件の区切りを認識
    .replace(/(概要|詳細要件)[:：]\s*/g, '$1:\n')
    // 段落の区切りを認識（句読点で終わる行の後）
    .replace(/([。！？])\s*([あ-んア-ン一-龯])/g, '$1\n$2');
}

function cleanExtractedTextWithLineBreaks(text: string): string {
  // まずポスト処理を適用
  let cleanedText = applyPostProcessingCorrection(text);
  
  // 文書構造を保持
  cleanedText = preserveDocumentStructure(cleanedText);
  
  return cleanedText
    // タブをスペースに変換
    .replace(/\t/g, ' ')
    // 行内の複数の連続するスペースを1つに（改行は保持）
    .replace(/[ \t]+/g, ' ')
    // 行の先頭と末尾のスペースを削除
    .replace(/^[ \t]+|[ \t]+$/gm, '')
    // 完全に空の行を削除
    .replace(/^\s*$/gm, '')
    // 3つ以上の連続する改行を2つに制限
    .replace(/\n{3,}/g, '\n\n')
    // 句読点の前後のスペースを完全に削除
    .replace(/\s*([。、！？])\s*/g, '$1')
    // 括弧の前後のスペースを完全に削除
    .replace(/\s*([（）「」『』【】〈〉《》〔〕［］｛｝])\s*/g, '$1')
    // コロン、セミコロンの前後のスペースを調整
    .replace(/\s*([:;])\s*/g, '$1 ')
    // カンマの前後のスペースを調整
    .replace(/\s*,\s*/g, ', ')
    // ピリオドの前後のスペースを調整
    .replace(/\s*\.\s*/g, '. ')
    // 英数字と日本語の間の不要なスペースを削除
    .replace(/([a-zA-Z0-9])\s+([あ-んア-ン一-龯])/g, '$1$2')
    .replace(/([あ-んア-ン一-龯])\s+([a-zA-Z0-9])/g, '$1$2')
    // 日本語文字間の不要なスペースを削除
    .replace(/([あ-んア-ン一-龯])\s+([あ-んア-ン一-龯])/g, '$1$2')
    // 数字と日本語の間の不要なスペースを削除
    .replace(/([0-9])\s+([あ-んア-ン一-龯])/g, '$1$2')
    .replace(/([あ-んア-ン一-龯])\s+([0-9])/g, '$1$2')
    // 連続する句読点の間のスペースを削除
    .replace(/([。、！？])\s+([。、！？])/g, '$1$2')
    // 見出しの後の改行を調整
    .replace(/(\d+\.\d*[^\n]*)\n+/g, '$1\n')
    // 箇条書きの後の改行を調整
    .replace(/([・\*\-\u2022][^\n]*)\n+/g, '$1\n')
    // 最終的なトリム
    .trim();
}

// テキストクリーニング関数（従来版）
function cleanExtractedText(text: string): string {
  return text
    // タブをスペースに変換
    .replace(/\t/g, ' ')
    // 複数の連続するスペースを1つに
    .replace(/\s+/g, ' ')
    // 行の先頭と末尾のスペースを削除
    .replace(/^\s+|\s+$/gm, '')
    // 空行を削除
    .replace(/^\s*$/gm, '')
    // 複数の連続する改行を2つに制限
    .replace(/\n\s*\n\s*\n+/g, '\n\n')
    // 句読点の前後のスペースを調整
    .replace(/\s+([。、！？])/g, '$1')
    .replace(/([。、！？])\s+/g, '$1 ')
    // 括弧の前後のスペースを調整
    .replace(/\s*([（）「」『』【】〈〉《》〔〕［］｛｝])\s*/g, '$1')
    // 英数字と日本語の間にスペースを追加（必要に応じて）
    .replace(/([a-zA-Z0-9])([あ-んア-ン一-龯])/g, '$1 $2')
    .replace(/([あ-んア-ン一-龯])([a-zA-Z0-9])/g, '$1 $2')
    // 最終的なトリム
    .trim();
}

// 画像前処理関数（OCR精度向上のため）
async function preprocessImageForOCR(filePath: string): Promise<string> {
  try {
    const processedPath = filePath.replace(/\.[^/.]+$/, '_processed.png');
    
    await sharp(filePath)
      .resize(null, 2000, { // 高さを2000pxに統一（300dpi相当）
        withoutEnlargement: true,
        fit: 'inside'
      })
      .grayscale() // グレースケール変換
      .normalize() // コントラスト正規化
      .sharpen({ sigma: 1, m1: 0.5, m2: 2, x1: 2, y2: 10 }) // シャープ化
      .png({ quality: 100 })
      .toFile(processedPath);
    
    return processedPath;
  } catch (error) {
    console.error('画像前処理エラー:', error);
    return filePath; // エラー時は元のファイルを使用
  }
}

// 文書構造認識のための前処理
async function preprocessForDocumentStructure(filePath: string): Promise<string> {
  try {
    const structurePath = filePath.replace(/\.[^/.]+$/, '_structure.png');
    
    await sharp(filePath)
      .resize(null, 2000, { withoutEnlargement: true, fit: 'inside' })
      .grayscale()
      .normalize()
      .threshold(128) // 二値化で文書構造を明確化
      .sharpen({ sigma: 2, m1: 1, m2: 3, x1: 3, y2: 15 }) // より強いシャープ化
      .png({ quality: 100 })
      .toFile(structurePath);
    
    return structurePath;
  } catch (error) {
    console.error('文書構造前処理エラー:', error);
    return filePath;
  }
}

// OCR処理関数（文書構造認識強化版）
async function extractTextFromImage(filePath: string): Promise<string> {
  let processedPath = filePath;
  let structurePath = filePath;
  
  try {
    // 通常の前処理と文書構造用前処理を並行実行
    const [normalProcessed, structureProcessed] = await Promise.all([
      preprocessImageForOCR(filePath),
      preprocessForDocumentStructure(filePath)
    ]);
    
    processedPath = normalProcessed;
    structurePath = structureProcessed;
    
    // 文書構造認識用のOCR設定
    const documentStructureModes = [
      { lang: 'jpn+eng', psm: ['1', '3', '6', '11'] }, // 横書き + スパーステキスト
      { lang: 'jpn_vert+eng', psm: ['5', '4'] }  // 縦書き
    ];
    
    let bestResult = '';
    let bestConfidence = 0;
    
    // 文書構造認識用のOCR実行
    for (const langMode of documentStructureModes) {
      for (const psmMode of langMode.psm) {
        try {
          const { data } = await Tesseract.recognize(structurePath, langMode.lang, {
            logger: m => console.log(m),
            // 文書構造認識に最適化された設定
            tessedit_pageseg_mode: psmMode,
            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをんがぎぐげござじずぜぞだぢづでどばびぶべぼぱぴぷぺぽゃゅょっー・、。！？（）「」『』【】〈〉《》〔〕［］｛｝',
            tessedit_min_char_size: '4',
            tessedit_max_char_size: '72',
            preserve_interword_spaces: '1',
            textord_old_baselines: '0',
            textord_min_linesize: '1.5',
            textord_min_xheight: '4',
            textord_force_make_prop_words: 'F',
            textord_really_old_xheight: 'F',
            // 文書構造認識のための追加設定
            textord_old_to_method: '0',
            textord_min_xheight: '4',
            // 改行と段落の認識を強化
            textord_old_baselines: '0',
            textord_min_linesize: '1.5',
            // 文字間隔の調整
            textord_force_make_prop_words: 'F',
            textord_really_old_xheight: 'F',
          });
          
          const confidence = data.confidence || 0;
          if (confidence > bestConfidence) {
            bestResult = data.text;
            bestConfidence = confidence;
          }
        } catch (psmError) {
          console.warn(`${langMode.lang} PSM ${psmMode} でエラー:`, psmError);
        }
      }
    }
    
    // 通常の前処理でも試行（フォールバック）
    if (bestConfidence < 50) {
      try {
        const { data } = await Tesseract.recognize(processedPath, 'jpn+eng', {
          logger: m => console.log(m),
          tessedit_pageseg_mode: '1',
          tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789あいうえおかきくけこさしすせそたちつてとなにぬねのはひふへほまみむめもやゆよらりるれろわをんがぎぐげござじずぜぞだぢづでどばびぶべぼぱぴぷぺぽゃゅょっー・、。！？（）「」『』【】〈〉《》〔〕［］｛｝',
          tessedit_min_char_size: '6',
          tessedit_max_char_size: '72',
          preserve_interword_spaces: '1',
          textord_old_baselines: '0',
          textord_min_linesize: '2.0',
          textord_min_xheight: '6',
          textord_force_make_prop_words: 'F',
          textord_really_old_xheight: 'F',
        });
        
        if (data.confidence > bestConfidence) {
          bestResult = data.text;
        }
      } catch (fallbackError) {
        console.warn('フォールバックOCRでエラー:', fallbackError);
      }
    }
    
    // 前処理ファイルを削除
    if (processedPath !== filePath && fs.existsSync(processedPath)) {
      fs.unlinkSync(processedPath);
    }
    if (structurePath !== filePath && fs.existsSync(structurePath)) {
      fs.unlinkSync(structurePath);
    }
    
    return cleanExtractedTextWithLineBreaks(bestResult || 'テキストを認識できませんでした');
  } catch (error) {
    console.error('OCR処理エラー:', error);
    
    // 前処理ファイルを削除
    if (processedPath !== filePath && fs.existsSync(processedPath)) {
      fs.unlinkSync(processedPath);
    }
    if (structurePath !== filePath && fs.existsSync(structurePath)) {
      fs.unlinkSync(structurePath);
    }
    
    return 'OCR処理中にエラーが発生しました';
  }
}

// PDFをOCRで処理する関数（フォールバック用）
async function extractTextFromPDFWithOCR(filePath: string): Promise<string> {
  try {
    // 注意: 実際のPDF→画像変換にはpdf2picやpdf-popplerが必要
    // 現在は簡易的な実装として、PDFファイルの情報を返す
    const stats = fs.statSync(filePath);
    const fileSizeKB = Math.round(stats.size / 1024);
    
    return `PDFファイルのOCR処理には、PDFを画像に変換する機能が必要です。
ファイル名: ${path.basename(filePath)}
ファイルサイズ: ${fileSizeKB}KB
OCR処理を有効にするには、pdf2picライブラリの追加実装が必要です。`;
  } catch (error) {
    console.warn('PDF OCR処理エラー:', error);
    return '';
  }
}

// PDFの内部構造からテキストを抽出する関数（pdfjs-dist使用）
async function extractTextFromPDFStructure(pdfBytes: Buffer): Promise<string> {
  try {
    // Canvas polyfillを設定
    const canvas = createCanvas(1, 1);
    const ctx = canvas.getContext('2d');
    
    // pdfjs-distを使用してPDFからテキストを抽出
    const loadingTask = pdfjsLib.getDocument({
      data: pdfBytes,
      useSystemFonts: true,
      verbosity: 0, // ログを抑制
      canvasFactory: {
        create: () => canvas,
        reset: () => {},
        destroy: () => {}
      }
    });
    
    const pdf = await loadingTask.promise;
    let extractedText = '';
    
    for (let pageNum = 1; pageNum <= Math.min(pdf.numPages, 20); pageNum++) {
      try {
        const page = await pdf.getPage(pageNum);
        const textContent = await page.getTextContent();
        
        // テキストアイテムを整理して抽出
        const pageText = textContent.items
          .map((item: any) => {
            if (item.str && item.str.trim()) {
              return item.str.trim();
            }
            return '';
          })
          .filter(text => text.length > 0)
          .join(' ');
        
        if (pageText) {
          extractedText += `=== ページ ${pageNum} ===\n${pageText}\n\n`;
        }
      } catch (pageError) {
        console.warn(`ページ ${pageNum}の処理エラー:`, pageError);
      }
    }
    
    return extractedText.trim();
  } catch (error) {
    console.warn('PDF構造解析エラー:', error);
    return '';
  }
}

// PDF解析関数（詳細版）
async function extractTextFromPDF(filePath: string, enableOCR: boolean = false): Promise<string> {
  try {
    const stats = fs.statSync(filePath);
    const fileSizeKB = Math.round(stats.size / 1024);
    
    // PDF文書を読み込み
    const pdfBytes = fs.readFileSync(filePath);
    const pdfDoc = await PDFDocument.load(pdfBytes);
    
    // PDF基本情報を取得
    const pageCount = pdfDoc.getPageCount();
    const title = pdfDoc.getTitle() || 'タイトルなし';
    const author = pdfDoc.getAuthor() || '作成者不明';
    const subject = pdfDoc.getSubject() || '件名なし';
    const creator = pdfDoc.getCreator() || '作成ソフト不明';
    const producer = pdfDoc.getProducer() || '変換ソフト不明';
    const creationDate = pdfDoc.getCreationDate();
    const modificationDate = pdfDoc.getModificationDate();
    
    // 作成日・更新日のフォーマット
    const formatDate = (date: Date | undefined) => {
      if (!date) return '不明';
      return date.toLocaleDateString('ja-JP', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    };
    
    // PDF構造情報を取得
    const pages = pdfDoc.getPages();
    const pageSizes = pages.map(page => {
      const { width, height } = page.getSize();
      return `${Math.round(width)}×${Math.round(height)}px`;
    });
    
    // テキスト抽出の試行（pdf-libを使用した簡易テキスト抽出）
    let extractedText = '';
    let textStats = '';
    try {
      // PDFの各ページからテキストを抽出
      const pages = pdfDoc.getPages();
      let allText = '';
      
      for (let i = 0; i < Math.min(pages.length, 10); i++) { // 最大10ページまで処理
        try {
          const page = pages[i];
          const { width, height } = page.getSize();
          
          // 注意: pdf-libは直接的なテキスト抽出機能を提供していません
          // 実際のテキスト抽出には、PDFの内部構造を解析する必要があります
          // 現在は構造情報とメタデータを提供
          allText += `=== ページ ${i + 1} ===\n`;
          allText += `サイズ: ${Math.round(width)}×${Math.round(height)}px\n`;
          allText += `テキスト抽出: PDFの内部構造解析が必要\n`;
          allText += `（実際のテキスト抽出には専用ライブラリが必要です）\n\n`;
        } catch (pageError) {
          console.warn(`ページ ${i + 1}の処理エラー:`, pageError);
          allText += `[ページ ${i + 1}: 処理エラー]\n`;
        }
      }
      
      // PDFに埋め込まれたテキストがある場合の抽出試行
      try {
        // pdfjs-distを使用してテキストを抽出
        const pdfText = await extractTextFromPDFStructure(pdfBytes);
        if (pdfText && pdfText.length > 0) {
          allText = `=== 抽出されたテキスト ===\n${pdfText}\n\n${allText}`;
        } else if (enableOCR) {
          // テキスト抽出に失敗した場合、OCRを試行
          console.log('テキスト抽出に失敗、OCR処理を開始...');
          const ocrText = await extractTextFromPDFWithOCR(filePath);
          if (ocrText && ocrText.length > 0) {
            allText = `=== OCR抽出されたテキスト ===\n${ocrText}\n\n${allText}`;
          }
        }
      } catch (structureError) {
        console.warn('PDF構造解析エラー:', structureError);
        if (enableOCR) {
          // エラーが発生した場合、OCRを試行
          try {
            const ocrText = await extractTextFromPDFWithOCR(filePath);
            if (ocrText && ocrText.length > 0) {
              allText = `=== OCR抽出されたテキスト ===\n${ocrText}\n\n${allText}`;
            }
          } catch (ocrError) {
            console.warn('OCR処理エラー:', ocrError);
          }
        }
      }
      
      extractedText = allText || '[テキストが抽出できませんでした]';
      textStats = `
文字数: ${allText.length}文字
ページ数: ${pages.length}ページ
情報: PDF構造解析実行（テキスト抽出は限定的）`;
    } catch (textError) {
      console.warn('テキスト抽出エラー:', textError);
      extractedText = '[テキスト抽出に失敗しました]';
      textStats = 'テキスト抽出エラーが発生しました';
    }
    
    // 分析結果を構造化
    const analysisResult = `
=== PDF分析結果 ===

【基本情報】
ファイル名: ${path.basename(filePath)}
ファイルサイズ: ${fileSizeKB}KB
ページ数: ${pageCount}ページ

【文書情報】
タイトル: ${title}
作成者: ${author}
件名: ${subject}
作成ソフト: ${creator}
変換ソフト: ${producer}
作成日: ${formatDate(creationDate)}
更新日: ${formatDate(modificationDate)}

【ページ情報】
${pages.map((page, index) => {
  const { width, height } = page.getSize();
  return `ページ ${index + 1}: ${Math.round(width)}×${Math.round(height)}px`;
}).join('\n')}

【テキスト抽出統計】
${textStats}

【抽出されたテキスト】
${extractedText}

【分析メモ】
- PDFの構造解析とテキスト抽出が完了しました
- 画像としてのOCR処理も可能です
- 抽出されたテキストは上記の通りです
    `.trim();
    
    // OCR処理が有効な場合、追加の分析を実行
    if (enableOCR && extractedText.length < 100) {
      try {
        // 注意: PDFを画像に変換してOCR処理を行う場合は、
        // 別途pdf2picやpdf-poppler等のライブラリが必要
        const ocrNote = `
        
【OCR分析】
- PDFのテキスト抽出が少ないため、OCR処理を推奨します
- 各ページを画像として変換してOCR処理を行うことが可能です
- より詳細な分析が必要な場合は、画像変換機能を有効にしてください`;
        return cleanExtractedTextWithLineBreaks(analysisResult + ocrNote);
      } catch (ocrError) {
        console.warn('OCR分析エラー:', ocrError);
      }
    }
    
    return cleanExtractedTextWithLineBreaks(analysisResult);
  } catch (error) {
    console.error('PDF解析エラー:', error);
    return `PDF解析に失敗しました: ${(error as Error).message}`;
  }
}

// テキストファイル読み取り関数
function extractTextFromTextFile(filePath: string): string {
  try {
    const text = fs.readFileSync(filePath, 'utf-8');
    return cleanExtractedTextWithLineBreaks(text);
  } catch (error) {
    console.error('テキストファイル読み取りエラー:', error);
    return 'テキストファイルの読み取りに失敗しました';
  }
}

// ファイルタイプに応じたテキスト抽出
async function extractTextFromFile(filePath: string, mimeType: string, options: { enableOCR?: boolean } = {}): Promise<string> {
  if (mimeType.startsWith('image/')) {
    return await extractTextFromImage(filePath);
  } else if (mimeType === 'application/pdf') {
    return await extractTextFromPDF(filePath, options.enableOCR);
  } else if (mimeType === 'text/plain') {
    return extractTextFromTextFile(filePath);
  } else {
    return 'サポートされていないファイル形式です';
  }
}

function getSummaries(): CardSummary[] {
  return Array.from(cardStore.values()).map((record) => record.summary);
}

function getMarketplaceCards(): MarketplaceCard[] {
  return Array.from(cardStore.values()).map((record) => ({
    summary: record.summary,
    reactions: record.reactions,
    pinned: false,
  }));
}

const boardService = new BoardService(
  async () => getSummaries(),
  combineSimilarities(createTagSimilarity(), createEventSimilarity(0.6)),
);

app.get('/api/health', (_req, res) => {
  res.json({ status: 'ok' });
});

app.get('/api/events', (_req, res) => {
  res.json({ events: getEvents() });
});

// イベント作成API
app.post('/api/events', (req, res) => {
  try {
    const { name, startDate, endDate, location } = req.body;

    // バリデーション
    if (!name || typeof name !== 'string' || name.trim().length === 0) {
      res.status(400).json({ message: 'イベント名は必須です' });
      return;
    }
    if (!startDate || typeof startDate !== 'string') {
      res.status(400).json({ message: '開始日は必須です' });
      return;
    }
    if (!endDate || typeof endDate !== 'string') {
      res.status(400).json({ message: '終了日は必須です' });
      return;
    }

    // 日付の妥当性チェック
    const start = new Date(startDate);
    const end = new Date(endDate);
    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      res.status(400).json({ message: '有効な日付を入力してください' });
      return;
    }
    if (start > end) {
      res.status(400).json({ message: '開始日は終了日より前である必要があります' });
      return;
    }

    // イベント名の重複チェック
    const existingEvents = getEvents();
    if (existingEvents.some(event => event.name.toLowerCase() === name.toLowerCase())) {
      res.status(400).json({ message: '同じ名前のイベントが既に存在します' });
      return;
    }

    // 新しいイベントを作成
    const newEvent: EventMeta = {
      id: `event-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name: name.trim(),
      startDate,
      endDate,
      location: location?.trim() || undefined,
    };

    // ストアに追加
    eventStore.set(newEvent.id, newEvent);

    res.status(201).json({ event: newEvent });
  } catch (error) {
    console.error('イベント作成エラー:', error);
    res.status(500).json({ message: 'イベントの作成に失敗しました' });
  }
});

app.get('/api/cards', (_req, res) => {
  res.json({ cards: getSummaries() });
});

app.get('/api/cards/:id', (req, res) => {
  const record = cardStore.get(req.params.id);
  if (!record) {
    res.status(404).json({ message: 'カードが見つかりません' });
    return;
  }
  res.json({ detail: record.detail });
});


// ファイルアップロード用エンドポイント
app.post('/api/upload', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      res.status(400).json({ message: 'ファイルがアップロードされていません' });
      return;
    }

    const { title, companyName, eventId, authorId = 'user-ryo', tags = [], memo } = req.body ?? {};
    
    if (!title || typeof title !== 'string') {
      res.status(400).json({ message: 'タイトルは必須です' });
      return;
    }
    if (!eventId) {
      res.status(400).json({ message: 'イベントは必須です' });
      return;
    }

    // ファイルからテキストを抽出
    const extractedText = await extractTextFromFile(req.file.path, req.file.mimetype, { enableOCR: false });
    
    // タグをパース
    const parsedTags = typeof tags === 'string' ? JSON.parse(tags) : tags;

    const newRecord = createCardRecord({
      title,
      companyName,
      eventId,
      authorId,
      ocrText: extractedText,
      tags: parsedTags,
      memo,
    });

    // ファイル情報を更新
    newRecord.detail.body.sourceFiles = [{
      id: `${newRecord.id}-file`,
      filename: req.file.filename,
      mimeType: req.file.mimetype,
      bytes: req.file.size,
    }];

    newRecord.timeseries = [
      {
        date: new Date().toISOString().slice(0, 10),
        views: newRecord.reactions.views,
        comments: newRecord.reactions.comments,
        likes: newRecord.reactions.likes,
      },
    ];
    newRecord.audience = [
      { department: '営業', ratio: 0.4 },
      { department: '開発', ratio: 0.3 },
      { department: '企画', ratio: 0.3 },
    ];

    cardStore.set(newRecord.id, newRecord);

    res.status(201).json({ 
      card: newRecord.detail, 
      summary: newRecord.summary,
      extractedText,
      fileUrl: `/uploads/${req.file.filename}`
    });
  } catch (error) {
    console.error('アップロードエラー:', error);
    res.status(500).json({ message: (error as Error).message });
  }
});

// Webクリップ用のメタデータ生成関数
function generateWebClipMetadata(url: string, title: string, description?: string) {
  const baseUrl = process.env.BASE_URL || 'http://localhost:5175';
  
  return {
    // Apple Webクリップ仕様に準拠したメタデータ
    appleWebApp: {
      capable: true,
      statusBarStyle: 'default',
      title: title || 'Webクリップ',
      startupImage: `${baseUrl}/assets/webclip-startup.png`,
      icons: [
        {
          sizes: '57x57',
          src: `${baseUrl}/assets/webclip-icon-57.png`,
          type: 'image/png'
        },
        {
          sizes: '72x72', 
          src: `${baseUrl}/assets/webclip-icon-72.png`,
          type: 'image/png'
        },
        {
          sizes: '114x114',
          src: `${baseUrl}/assets/webclip-icon-114.png`,
          type: 'image/png'
        },
        {
          sizes: '144x144',
          src: `${baseUrl}/assets/webclip-icon-144.png`,
          type: 'image/png'
        },
        {
          sizes: '180x180',
          src: `${baseUrl}/assets/webclip-icon-180.png`,
          type: 'image/png'
        }
      ]
    },
    // 標準的なWebアプリマニフェスト
    manifest: {
      name: title || 'Webクリップ',
      short_name: title?.substring(0, 12) || 'Webクリップ',
      description: description || 'Webクリップアプリケーション',
      start_url: url,
      display: 'standalone',
      orientation: 'portrait',
      theme_color: '#007AFF',
      background_color: '#FFFFFF',
      icons: [
        {
          src: `${baseUrl}/assets/webclip-icon-192.png`,
          sizes: '192x192',
          type: 'image/png'
        },
        {
          src: `${baseUrl}/assets/webclip-icon-512.png`,
          sizes: '512x512',
          type: 'image/png'
        }
      ]
    },
    // 構成プロファイル用の設定
    configurationProfile: {
      PayloadType: 'com.apple.webClip.managed',
      PayloadVersion: 1,
      PayloadIdentifier: `com.insightbox.webclip.${Date.now()}`,
      PayloadDisplayName: title || 'Webクリップ',
      PayloadDescription: description || 'Insight-Box Webクリップ',
      PayloadOrganization: 'Insight-Box',
      PayloadScope: 'User',
      URL: url,
      Label: title || 'Webクリップ',
      Icon: {
        Data: '', // Base64エンコードされたアイコンデータ
        ContentType: 'image/png'
      },
      IsRemovable: true,
      Precomposed: false,
      FullScreen: true,
      IgnoreManifestScope: false
    }
  };
}

// Webクリップ用エンドポイント
app.post('/api/webclip', (req, res) => {
  try {
    const { title, url, content, eventId, authorId = 'user-ryo', tags = [], memo, description } = req.body ?? {};
    
    if (!title || typeof title !== 'string') {
      res.status(400).json({ message: 'タイトルは必須です' });
      return;
    }
    if (!eventId) {
      res.status(400).json({ message: 'イベントは必須です' });
      return;
    }
    if (!url || typeof url !== 'string') {
      res.status(400).json({ message: 'URLは必須です' });
      return;
    }

    // URLの妥当性チェック
    try {
      new URL(url);
    } catch (error) {
      res.status(400).json({ message: '有効なURLを入力してください' });
      return;
    }

    const newRecord = createCardRecord({
      title,
      companyName: new URL(url).hostname,
      eventId,
      authorId,
      ocrText: content || `Webページ: ${url}`,
      tags,
      memo,
    });

    // Webクリップ用メタデータを生成
    const webClipMetadata = generateWebClipMetadata(url, title, description);

    // Webクリップ情報を追加
    newRecord.detail.body.sourceFiles = [{
      id: `${newRecord.id}-webclip`,
      filename: `${new URL(url).hostname}.html`,
      mimeType: 'text/html',
      bytes: content ? content.length : 0,
    }];

    newRecord.detail.body.highlights = [
      `Webクリップ: ${url}`,
      ...(memo ? [memo] : [])
    ];

    // Webクリップ用の追加メタデータを保存
    newRecord.detail.body.webClipMetadata = webClipMetadata;

    cardStore.set(newRecord.id, newRecord);

    res.status(201).json({ 
      card: newRecord.detail, 
      summary: newRecord.summary,
      webclipUrl: url,
      webClipMetadata: webClipMetadata
    });
  } catch (error) {
    console.error('Webクリップエラー:', error);
    res.status(500).json({ message: (error as Error).message });
  }
});

// Webクリップ用のHTML生成エンドポイント
app.get('/api/webclip/:cardId/html', (req, res) => {
  try {
    const { cardId } = req.params;
    const card = cardStore.get(cardId);
    
    if (!card) {
      res.status(404).json({ message: 'カードが見つかりません' });
      return;
    }

    const webClipMetadata = card.detail.body.webClipMetadata;
    if (!webClipMetadata) {
      res.status(404).json({ message: 'Webクリップメタデータが見つかりません' });
      return;
    }

    const html = `
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${webClipMetadata.manifest.name}</title>
    
    <!-- Apple Web App Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="${webClipMetadata.appleWebApp.statusBarStyle}">
    <meta name="apple-mobile-web-app-title" content="${webClipMetadata.appleWebApp.title}">
    
    <!-- Apple Touch Icons -->
    ${webClipMetadata.appleWebApp.icons.map(icon => 
      `<link rel="apple-touch-icon" sizes="${icon.sizes}" href="${icon.src}">`
    ).join('\n    ')}
    
    <!-- Startup Image -->
    <link rel="apple-touch-startup-image" href="${webClipMetadata.appleWebApp.startupImage}">
    
    <!-- Web App Manifest -->
    <link rel="manifest" href="/api/webclip/${cardId}/manifest.json">
    
    <!-- Theme Colors -->
    <meta name="theme-color" content="${webClipMetadata.manifest.theme_color}">
    <meta name="msapplication-navbutton-color" content="${webClipMetadata.manifest.theme_color}">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: ${webClipMetadata.manifest.background_color};
            color: #333;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .description {
            color: #666;
            font-size: 16px;
        }
        .content {
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }
        .url {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 8px;
            word-break: break-all;
            margin: 20px 0;
        }
        .button {
            display: inline-block;
            background: ${webClipMetadata.manifest.theme_color};
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 8px;
            font-weight: bold;
            margin: 10px 5px;
        }
        .button:hover {
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="content">
        <div class="header">
            <div class="title">${webClipMetadata.manifest.name}</div>
            <div class="description">${webClipMetadata.manifest.description}</div>
        </div>
        
        <div class="url">
            <strong>URL:</strong> ${webClipMetadata.manifest.start_url}
        </div>
        
        <p>このWebクリップをホーム画面に追加するには、Safariで「共有」ボタンをタップし、「ホーム画面に追加」を選択してください。</p>
        
        <a href="${webClipMetadata.manifest.start_url}" class="button" target="_blank">
            元のサイトを開く
        </a>
        
        <a href="/api/webclip/${cardId}/manifest.json" class="button" download>
            マニフェストをダウンロード
        </a>
    </div>
</body>
</html>`;

    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.send(html);
  } catch (error) {
    console.error('WebクリップHTML生成エラー:', error);
    res.status(500).json({ message: 'HTML生成に失敗しました' });
  }
});

// Webクリップ用のマニフェスト生成エンドポイント
app.get('/api/webclip/:cardId/manifest.json', (req, res) => {
  try {
    const { cardId } = req.params;
    const card = cardStore.get(cardId);
    
    if (!card) {
      res.status(404).json({ message: 'カードが見つかりません' });
      return;
    }

    const webClipMetadata = card.detail.body.webClipMetadata;
    if (!webClipMetadata) {
      res.status(404).json({ message: 'Webクリップメタデータが見つかりません' });
      return;
    }

    res.setHeader('Content-Type', 'application/json');
    res.json(webClipMetadata.manifest);
  } catch (error) {
    console.error('Webクリップマニフェスト生成エラー:', error);
    res.status(500).json({ message: 'マニフェスト生成に失敗しました' });
  }
});

// Webクリップ用の構成プロファイル生成エンドポイント
app.get('/api/webclip/:cardId/profile.mobileconfig', (req, res) => {
  try {
    const { cardId } = req.params;
    const card = cardStore.get(cardId);
    
    if (!card) {
      res.status(404).json({ message: 'カードが見つかりません' });
      return;
    }

    const webClipMetadata = card.detail.body.webClipMetadata;
    if (!webClipMetadata) {
      res.status(404).json({ message: 'Webクリップメタデータが見つかりません' });
      return;
    }

    const profile = {
      PayloadContent: [webClipMetadata.configurationProfile],
      PayloadDisplayName: webClipMetadata.configurationProfile.PayloadDisplayName,
      PayloadDescription: webClipMetadata.configurationProfile.PayloadDescription,
      PayloadIdentifier: webClipMetadata.configurationProfile.PayloadIdentifier,
      PayloadOrganization: webClipMetadata.configurationProfile.PayloadOrganization,
      PayloadRemovalDisallowed: false,
      PayloadType: 'Configuration',
      PayloadUUID: `uuid-${Date.now()}`,
      PayloadVersion: 1
    };

    res.setHeader('Content-Type', 'application/x-apple-aspen-config');
    res.setHeader('Content-Disposition', `attachment; filename="webclip-${cardId}.mobileconfig"`);
    res.send(JSON.stringify(profile, null, 2));
  } catch (error) {
    console.error('Webクリップ構成プロファイル生成エラー:', error);
    res.status(500).json({ message: '構成プロファイル生成に失敗しました' });
  }
});

app.post('/api/cards', (req, res) => {
  const {
    title,
    companyName,
    eventId,
    authorId = 'user-ryo',
    ocrText = '',
    tags = [],
    memo,
  } = req.body ?? {};

  if (!title || typeof title !== 'string') {
    res.status(400).json({ message: 'タイトルは必須です' });
    return;
  }
  if (!eventId) {
    res.status(400).json({ message: 'イベントは必須です' });
    return;
  }
  if (tags.length > LIMITS.tagsMaxPerCard) {
    res.status(400).json({ message: `タグは${LIMITS.tagsMaxPerCard}件以内です` });
    return;
  }

  const newRecord = createCardRecord({
    title,
    companyName,
    eventId,
    authorId,
    ocrText,
    tags,
    memo,
  });

  newRecord.timeseries = [
    {
      date: new Date().toISOString().slice(0, 10),
      views: newRecord.reactions.views,
      comments: newRecord.reactions.comments,
      likes: newRecord.reactions.likes,
    },
  ];
  newRecord.audience = [
    { department: '営業', ratio: 0.4 },
    { department: '開発', ratio: 0.3 },
    { department: '企画', ratio: 0.3 },
  ];

  cardStore.set(newRecord.id, newRecord);

  res.status(201).json({ card: newRecord.detail, summary: newRecord.summary });
});

app.get('/api/board', async (req, res) => {
  try {
    const outputs = await boardService.loadBoard({
      tagIds: req.query.tagIds ? String(req.query.tagIds).split(',') : undefined,
      eventIds: req.query.eventIds ? String(req.query.eventIds).split(',') : undefined,
    });
    res.json(outputs);
  } catch (error) {
    res.status(500).json({ message: (error as Error).message });
  }
});

app.post('/api/templates/apply', async (req, res) => {
  const inputs = req.body as TemplateModalInputs;
  const summarize = async (slot: TemplateModalInputs['slots'][number]) =>
    `${slot.label}:
${slot.cardIds.length}件のカードを配置`;
  try {
    const result: TemplateModalOutputs = await boardService.applyTemplate(inputs, summarize);
    res.json(result);
  } catch (error) {
    res.status(500).json({ message: (error as Error).message });
  }
});

app.get('/api/marketplace', (_req, res) => {
  const cards = getMarketplaceCards();
  const response: MarketplaceOutputs = {
    cards,
    state: 'success',
  };
  res.json(response);
});

app.post('/api/share', (req, res) => {
  const inputs = req.body as ShareModalInputs;
  if (!inputs?.cardId) {
    res.status(400).json({ message: 'cardIdが必要です' });
    return;
  }
  const record = cardStore.get(inputs.cardId);
  if (!record) {
    res.status(404).json({ message: 'カードが見つかりません' });
    return;
  }
  const shareUrl = `https://insight-box.local/share/${inputs.cardId}?token=${uuid().slice(0, 8)}`;
  const result: ShareModalOutputs = {
    shareUrl,
    postedToSlack: Boolean(inputs.slackTargets?.length),
    state: 'success',
  };
  res.json(result);
});

let settings: SettingsRolesInputs = {
  defaultScope: 'team',
  eventUploadMax: LIMITS.eventUploadMax,
};

app.get('/api/settings/roles', (_req, res) => {
  res.json({ settings });
});

app.post('/api/settings/roles', (req, res) => {
  const next = req.body as SettingsRolesInputs;
  if (!['team', 'org'].includes(next.defaultScope)) {
    res.status(400).json({ message: 'defaultScopeが不正です' });
    return;
  }
  if (next.eventUploadMax < 1 || next.eventUploadMax > 200) {
    res.status(400).json({ message: 'eventUploadMaxが範囲外です' });
    return;
  }
  settings = next;
  res.json({ applied: true, state: 'success' satisfies ViewState });
});

app.get('/api/analytics/personal', (_req, res) => {
  const reactions = Array.from(cardStore.values()).reduce<ReactionSummary>((acc, record) => ({
    views: acc.views + record.reactions.views,
    comments: acc.comments + record.reactions.comments,
    likes: acc.likes + record.reactions.likes,
  }), { views: 0, comments: 0, likes: 0 });

  const timeseries = Array.from(cardStore.values())[0]?.timeseries ?? [];
  res.json({
    kpis: reactions,
    timeseries,
    state: 'success',
  });
});

app.get('/api/analytics/cards/:id', (req, res) => {
  const record = cardStore.get(req.params.id);
  if (!record) {
    res.status(404).json({ message: 'カードが見つかりません' });
    return;
  }
  res.json({
    kpis: record.reactions,
    timeseries: record.timeseries,
    audienceDistribution: record.audience,
    state: 'success',
  });
});

// 統一REST APIのデータ構造
interface Document {
  id: string;
  source: {
    type: 'file' | 'url';
    url?: string;
    filename?: string;
    size?: number;
    mime_type?: string;
  };
  meta: {
    expo?: string;
    booth?: string;
    event_id?: string;
    captured_at: string;
    device?: string;
  };
  tasks: string[]; // ['ocr', 'web_clip', 'pdf_analyze']
  status: 'queued' | 'processing' | 'completed' | 'failed';
  created_at: string;
  updated_at: string;
  artifacts: {
    text?: string;
    entities?: any;
    pages?: any[];
    original?: string;
  };
}

interface Job {
  id: string;
  document_id: string;
  status: 'queued' | 'processing' | 'succeeded' | 'failed';
  progress: number;
  tasks: string[];
  created_at: string;
  started_at?: string;
  completed_at?: string;
  error?: string;
  artifacts: Array<{
    type: string;
    url: string;
    metadata?: any;
  }>;
}

// ハイブリッドOCRシステム用のデータ構造（後方互換性のため保持）
interface HybridOCRResult {
  doc_id: string;
  source: {
    expo?: string;
    booth?: string;
    captured_at: string;
    device: string;
    event_id?: string;
  };
  ocr: {
    text: string;
    engine: 'mobile_primary' | 'ppocrv4' | 'tesseract_jpn_vert' | 'trocr';
    confidence_avg: number;
    processing_time_ms: number;
    quality: 'high' | 'medium' | 'low';
    quality_issues: string[];
  };
  entities: {
    company: string[];
    products: string[];
    contacts: {
      email: string[];
      tel: string[];
      url: string[];
    };
  };
  layout: Array<{
    type: 'heading' | 'paragraph' | 'list' | 'table';
    bbox: number[];
    text: string;
  }>;
  tags: string[];
  file: {
    original_url: string;
    thumb_url?: string;
  };
  metadata: {
    page_count: number;
    file_size: number;
    mime_type: string;
  };
}

// OCR品質チェック関数
function checkOCRQuality(text: string): { quality: 'high' | 'medium' | 'low'; issues: string[] } {
  const issues: string[] = [];
  let quality: 'high' | 'medium' | 'low' = 'high';

  // 意味不明な文字列の検出
  const gibberishPattern = /[A-Z]{4,}[^a-z\s]{2,}|[A-Z]{2,}[^a-z\s]{4,}/g;
  const gibberishMatches = text.match(gibberishPattern);
  if (gibberishMatches && gibberishMatches.length > 0) {
    issues.push(`意味不明な文字列を検出: ${gibberishMatches.slice(0, 3).join(', ')}`);
    quality = 'low';
  }

  // 連続する大文字の検出
  const consecutiveCaps = /[A-Z]{5,}/g;
  const capsMatches = text.match(consecutiveCaps);
  if (capsMatches && capsMatches.length > 0) {
    issues.push(`連続する大文字を検出: ${capsMatches.slice(0, 3).join(', ')}`);
    if (quality === 'high') quality = 'medium';
  }

  // 文字密度のチェック
  const totalChars = text.length;
  const japaneseChars = (text.match(/[あ-んア-ン一-龯]/g) || []).length;
  const englishChars = (text.match(/[a-zA-Z]/g) || []).length;
  const numberChars = (text.match(/[0-9]/g) || []).length;
  const otherChars = totalChars - japaneseChars - englishChars - numberChars;

  if (otherChars / totalChars > 0.3) {
    issues.push('特殊文字の割合が高い');
    if (quality === 'high') quality = 'medium';
  }

  // 文字認識の信頼度推定
  const commonWords = ['株式会社', '有限会社', '合同会社', '株式会社', 'the', 'and', 'or', 'of', 'in', 'to', 'for'];
  const foundCommonWords = commonWords.filter(word => text.toLowerCase().includes(word.toLowerCase())).length;
  
  if (foundCommonWords === 0 && totalChars > 50) {
    issues.push('一般的な単語が検出されない');
    if (quality === 'high') quality = 'medium';
  }

  return { quality, issues };
}

// OCR結果の後処理と品質改善
function improveOCRResult(text: string): { improvedText: string; quality: 'high' | 'medium' | 'low'; issues: string[] } {
  const qualityCheck = checkOCRQuality(text);
  let improvedText = text;

  // 意味不明な文字列の修正試行
  if (qualityCheck.quality === 'low') {
    // 一般的なOCR誤りパターンの修正
    const corrections = [
      // よくある文字の誤認識パターン
      { pattern: /BOLAHHERII/g, replacement: '株式会社' },
      { pattern: /FEDRIOEETR/g, replacement: '有限会社' },
      { pattern: /RORKEMHFLI/g, replacement: '合同会社' },
      { pattern: /ZELRENR/g, replacement: '株式会社' },
      { pattern: /BRRSh/g, replacement: '株式会社' },
      { pattern: /Y—Z/g, replacement: '株式会社' },
      // その他の一般的なパターン
      { pattern: /[A-Z]{4,}[^a-z\s]{2,}/g, replacement: '[認識エラー]' },
      { pattern: /[A-Z]{2,}[^a-z\s]{4,}/g, replacement: '[認識エラー]' },
    ];

    corrections.forEach(correction => {
      improvedText = improvedText.replace(correction.pattern, correction.replacement);
    });
  }

  // 改善後の品質再チェック
  const improvedQualityCheck = checkOCRQuality(improvedText);
  
  return {
    improvedText,
    quality: improvedQualityCheck.quality,
    issues: improvedQualityCheck.issues
  };
}

// エンティティ抽出関数
function extractEntities(text: string): HybridOCRResult['entities'] {
  const entities: HybridOCRResult['entities'] = {
    company: [],
    products: [],
    contacts: {
      email: [],
      tel: [],
      url: []
    }
  };

  // メールアドレス抽出
  const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
  entities.contacts.email = [...new Set(text.match(emailRegex) || [])];

  // 電話番号抽出（日本の形式）
  const telRegex = /(\d{2,4}-\d{2,4}-\d{4}|\d{10,11}|\d{3}-\d{4}-\d{4})/g;
  entities.contacts.tel = [...new Set(text.match(telRegex) || [])];

  // URL抽出
  const urlRegex = /https?:\/\/[^\s]+/g;
  entities.contacts.url = [...new Set(text.match(urlRegex) || [])];

  // 会社名抽出（株式会社、有限会社、合同会社等）
  const companyRegex = /([^\s]+(?:株式会社|有限会社|合同会社|合資会社|合名会社|一般社団法人|一般財団法人|公益社団法人|公益財団法人|学校法人|医療法人|社会福祉法人|NPO法人|協同組合|事業協同組合|企業組合|協業組合|信用組合|信用金庫|労働金庫|農業協同組合|漁業協同組合|森林組合|生活協同組合|消費生活協同組合)[^\s]*)/g;
  entities.company = [...new Set(text.match(companyRegex) || [])];

  // 製品名抽出（一般的な製品名パターン）
  const productRegex = /([A-Z][a-zA-Z0-9\s]+(?:Suite|System|Platform|Service|Solution|Cloud|AI|IoT|API|SDK|Framework|Engine|Studio|Pro|Enterprise|Business|Standard|Basic|Premium|Advanced|Professional)[^\s]*)/g;
  entities.products = [...new Set(text.match(productRegex) || [])];

  return entities;
}

// レイアウト解析関数
function analyzeLayout(text: string): HybridOCRResult['layout'] {
  const layout: HybridOCRResult['layout'] = [];
  const lines = text.split('\n');

  lines.forEach((line, index) => {
    const trimmedLine = line.trim();
    if (!trimmedLine) return;

    let type: HybridOCRResult['layout'][0]['type'] = 'paragraph';
    
    // 見出し判定
    if (/^\d+\.\d*/.test(trimmedLine) || /^[#*]{1,3}\s/.test(trimmedLine)) {
      type = 'heading';
    }
    // 箇条書き判定
    else if (/^[・\*\-\u2022]\s/.test(trimmedLine)) {
      type = 'list';
    }
    // 表判定（簡易）
    else if (/\t/.test(trimmedLine) || /\s{3,}/.test(trimmedLine)) {
      type = 'table';
    }

    layout.push({
      type,
      bbox: [0, index * 20, 100, (index + 1) * 20], // 簡易的な座標
      text: trimmedLine
    });
  });

  return layout;
}

// タグ生成関数
function generateTags(entities: HybridOCRResult['entities'], text: string): string[] {
  const tags: string[] = [];

  // エンティティベースのタグ
  if (entities.contacts.email.length > 0) tags.push('連絡先');
  if (entities.contacts.tel.length > 0) tags.push('電話番号');
  if (entities.contacts.url.length > 0) tags.push('Webサイト');
  if (entities.company.length > 0) tags.push('企業情報');
  if (entities.products.length > 0) tags.push('製品情報');

  // キーワードベースのタグ
  const keywords = {
    'AI': /AI|人工知能|機械学習|深層学習|ディープラーニング/i,
    'SaaS': /SaaS|クラウド|クラウドサービス|ソフトウェア/i,
    '製造業': /製造|工場|生産|品質管理|IoT|産業/i,
    'IT': /IT|情報技術|システム|ソフトウェア|アプリ/i,
    'マーケティング': /マーケティング|営業|販売|プロモーション/i,
    '人事': /人事|採用|人材|HR|組織/i,
    '財務': /財務|会計|経理|予算|資金/i
  };

  Object.entries(keywords).forEach(([tag, regex]) => {
    if (regex.test(text)) {
      tags.push(tag);
    }
  });

  return [...new Set(tags)];
}

// モバイル一次OCR用エンドポイント
app.post('/api/ingest', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'ファイルがアップロードされていません' });
    }

    const docId = `doc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const startTime = Date.now();

    // 一次OCR処理（軽量・高速）
    const rawText = await extractTextFromImage(req.file.path);
    const primaryTime = Date.now() - startTime;
    
    // OCR品質チェックと改善
    const { improvedText: primaryText, quality, issues } = improveOCRResult(rawText);
    const primaryConfidence = quality === 'high' ? 0.85 : quality === 'medium' ? 0.65 : 0.35;

    // エンティティ抽出
    const entities = extractEntities(primaryText);
    const layout = analyzeLayout(primaryText);
    const tags = generateTags(entities, primaryText);

    // ハイブリッドOCR結果の構築
    const result: HybridOCRResult = {
      doc_id: docId,
      source: {
        expo: req.body.expo || 'Unknown Expo',
        booth: req.body.booth || 'Unknown Booth',
        captured_at: new Date().toISOString(),
        device: req.body.device || 'Unknown Device',
        event_id: req.body.event_id
      },
      ocr: {
        text: primaryText,
        engine: 'mobile_primary',
        confidence_avg: primaryConfidence,
        processing_time_ms: primaryTime,
        quality,
        quality_issues: issues
      },
      entities,
      layout,
      tags,
      file: {
        original_url: `/uploads/${req.file.filename}`,
        thumb_url: `/uploads/${req.file.filename}`
      },
      metadata: {
        page_count: 1,
        file_size: req.file.size,
        mime_type: req.file.mimetype
      }
    };

    // 結果を保存（簡易的なメモリ保存）
    if (!global.hybridResults) {
      global.hybridResults = new Map();
    }
    if (!global.documents) {
      global.documents = new Map();
    }
    if (!global.jobs) {
      global.jobs = new Map();
    }
    global.hybridResults.set(docId, result);

    res.json({
      success: true,
      doc_id: docId,
      result,
      message: '一次OCR処理が完了しました。帰社後に高精度仕上げを実行できます。'
    });

  } catch (error) {
    console.error('一次OCR処理エラー:', error);
    res.status(500).json({ error: '一次OCR処理中にエラーが発生しました' });
  }
});

// 高精度再処理エンドポイント
app.post('/api/re-ocr/:docId', async (req, res) => {
  try {
    const { docId } = req.params;
    const { engine = 'ppocrv4' } = req.body;

    if (!global.hybridResults || !global.hybridResults.has(docId)) {
      return res.status(404).json({ error: 'ドキュメントが見つかりません' });
    }

    const originalResult = global.hybridResults.get(docId);
    const startTime = Date.now();

    // 高精度OCR処理
    let rawHighPrecisionText: string;
    let confidence: number;
    let engineUsed: HybridOCRResult['ocr']['engine'];

    switch (engine) {
      case 'ppocrv4':
        // PaddleOCR v4のシミュレーション（実際の実装では外部API呼び出し）
        rawHighPrecisionText = await extractTextFromImage(originalResult.file.original_url.replace('/uploads/', './uploads/'));
        confidence = 0.95;
        engineUsed = 'ppocrv4';
        break;
      case 'trocr':
        // TrOCRのシミュレーション
        rawHighPrecisionText = await extractTextFromImage(originalResult.file.original_url.replace('/uploads/', './uploads/'));
        confidence = 0.92;
        engineUsed = 'trocr';
        break;
      case 'tesseract_jpn_vert':
        // Tesseract縦書きのシミュレーション
        rawHighPrecisionText = await extractTextFromImage(originalResult.file.original_url.replace('/uploads/', './uploads/'));
        confidence = 0.88;
        engineUsed = 'tesseract_jpn_vert';
        break;
      default:
        return res.status(400).json({ error: 'サポートされていないOCRエンジンです' });
    }

    // 高精度OCR結果の品質チェックと改善
    const { improvedText: highPrecisionText, quality, issues } = improveOCRResult(rawHighPrecisionText);
    const adjustedConfidence = quality === 'high' ? confidence : quality === 'medium' ? confidence * 0.8 : confidence * 0.6;

    const processingTime = Date.now() - startTime;

    // 高精度結果でエンティティ再抽出
    const highPrecisionEntities = extractEntities(highPrecisionText);
    const highPrecisionLayout = analyzeLayout(highPrecisionText);
    const highPrecisionTags = generateTags(highPrecisionEntities, highPrecisionText);

    // 結果を更新
    const updatedResult: HybridOCRResult = {
      ...originalResult,
      ocr: {
        text: highPrecisionText,
        engine: engineUsed,
        confidence_avg: adjustedConfidence,
        processing_time_ms: processingTime,
        quality,
        quality_issues: issues
      },
      entities: highPrecisionEntities,
      layout: highPrecisionLayout,
      tags: highPrecisionTags
    };

    global.hybridResults.set(docId, updatedResult);

    res.json({
      success: true,
      doc_id: docId,
      result: updatedResult,
      message: '高精度OCR処理が完了しました。'
    });

  } catch (error) {
    console.error('高精度OCR処理エラー:', error);
    res.status(500).json({ error: '高精度OCR処理中にエラーが発生しました' });
  }
});

// 検索エンドポイント
app.get('/api/search', (req, res) => {
  try {
    const { q: query, filters } = req.query;
    
    if (!global.hybridResults) {
      return res.json({ results: [], total: 0 });
    }

    let results = Array.from(global.hybridResults.values());

    // テキスト検索
    if (query) {
      const searchQuery = query.toString().toLowerCase();
      results = results.filter(result => 
        result.ocr.text.toLowerCase().includes(searchQuery) ||
        result.entities.company.some(company => company.toLowerCase().includes(searchQuery)) ||
        result.entities.products.some(product => product.toLowerCase().includes(searchQuery)) ||
        result.tags.some(tag => tag.toLowerCase().includes(searchQuery))
      );
    }

    // フィルタリング
    if (filters) {
      const filterArray = filters.toString().split(',');
      results = results.filter(result => 
        filterArray.some(filter => result.tags.includes(filter))
      );
    }

    res.json({
      results: results.slice(0, 50), // 最大50件
      total: results.length,
      query: query || '',
      filters: filters || ''
    });

  } catch (error) {
    console.error('検索エラー:', error);
    res.status(500).json({ error: '検索中にエラーが発生しました' });
  }
});

// ドキュメント詳細取得エンドポイント
app.get('/api/docs/:docId', (req, res) => {
  try {
    const { docId } = req.params;

    if (!global.hybridResults || !global.hybridResults.has(docId)) {
      return res.status(404).json({ error: 'ドキュメントが見つかりません' });
    }

    const result = global.hybridResults.get(docId);
    res.json({ success: true, result });

  } catch (error) {
    console.error('ドキュメント取得エラー:', error);
    res.status(500).json({ error: 'ドキュメント取得中にエラーが発生しました' });
  }
});

// ハイブリッドOCR結果一覧取得
app.get('/api/hybrid-results', (req, res) => {
  try {
    if (!global.hybridResults) {
      return res.json({ results: [], total: 0 });
    }

    const results = Array.from(global.hybridResults.values());
    res.json({
      results: results.slice(0, 100), // 最大100件
      total: results.length
    });

  } catch (error) {
    console.error('ハイブリッド結果取得エラー:', error);
    res.status(500).json({ error: '結果取得中にエラーが発生しました' });
  }
});

// PDF分析専用エンドポイント
app.post('/api/analyze-pdf', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      res.status(400).json({ message: 'ファイルがアップロードされていません' });
      return;
    }

    if (req.file.mimetype !== 'application/pdf') {
      res.status(400).json({ message: 'PDFファイルのみサポートしています' });
      return;
    }

    const { enableOCR = false, detailedAnalysis = true } = req.body ?? {};

    // 詳細なPDF分析を実行
    const analysisResult = await extractTextFromPDF(req.file.path, enableOCR === 'true' || enableOCR === true);

    // 追加の分析情報
    const stats = fs.statSync(req.file.path);
    const fileSizeKB = Math.round(stats.size / 1024);

    const response = {
      success: true,
      fileName: req.file.originalname,
      fileSize: fileSizeKB,
      mimeType: req.file.mimetype,
      analysisResult,
      analysisOptions: {
        enableOCR: enableOCR === 'true' || enableOCR === true,
        detailedAnalysis: detailedAnalysis === 'true' || detailedAnalysis === true
      },
      timestamp: new Date().toISOString()
    };

    res.json(response);

  } catch (error) {
    console.error('PDF分析エラー:', error);
    res.status(500).json({ 
      success: false,
      message: 'PDF分析中にエラーが発生しました',
      error: (error as Error).message 
    });
  }
});

// ===== 統一REST API v1 =====

// 1) ドキュメント作成（アップロード/URL取り込み）
app.post('/v1/documents', async (req, res) => {
  try {
    const { source, tasks, meta, options } = req.body;
    const idempotencyKey = req.headers['idempotency-key'] as string;
    
    // ドキュメントIDを生成
    const documentId = `doc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const jobId = `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // ドキュメント作成
    const document: Document = {
      id: documentId,
      source,
      meta: {
        ...meta,
        captured_at: new Date().toISOString()
      },
      tasks,
      status: 'queued',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      artifacts: {}
    };
    
    // ジョブ作成
    const job: Job = {
      id: jobId,
      document_id: documentId,
      status: 'queued',
      progress: 0,
      tasks,
      created_at: new Date().toISOString(),
      artifacts: []
    };
    
    // 保存
    if (!global.documents) global.documents = new Map();
    if (!global.jobs) global.jobs = new Map();
    
    global.documents.set(documentId, document);
    global.jobs.set(jobId, job);
    
    // 非同期処理を開始
    processDocumentAsync(documentId, jobId, source, tasks, options);
    
    res.status(202).json({
      document_id: documentId,
      job_id: jobId,
      status: 'queued'
    });
    
  } catch (error) {
    console.error('ドキュメント作成エラー:', error);
    res.status(500).json({ error: 'ドキュメント作成中にエラーが発生しました' });
  }
});

// 2) ジョブ確認・完了結果
app.get('/v1/jobs/:jobId', (req, res) => {
  try {
    const { jobId } = req.params;
    
    if (!global.jobs || !global.jobs.has(jobId)) {
      return res.status(404).json({ error: 'ジョブが見つかりません' });
    }
    
    const job = global.jobs.get(jobId)!;
    res.json(job);
    
  } catch (error) {
    console.error('ジョブ取得エラー:', error);
    res.status(500).json({ error: 'ジョブ取得中にエラーが発生しました' });
  }
});

// 3) ドキュメント取得（統一インターフェース）
app.get('/v1/documents/:id', (req, res) => {
  try {
    const { id } = req.params;
    
    if (!global.documents || !global.documents.has(id)) {
      return res.status(404).json({ error: 'ドキュメントが見つかりません' });
    }
    
    const document = global.documents.get(id)!;
    res.json(document);
    
  } catch (error) {
    console.error('ドキュメント取得エラー:', error);
    res.status(500).json({ error: 'ドキュメント取得中にエラーが発生しました' });
  }
});

// ドキュメントのテキスト取得
app.get('/v1/documents/:id/text', (req, res) => {
  try {
    const { id } = req.params;
    
    if (!global.documents || !global.documents.has(id)) {
      return res.status(404).json({ error: 'ドキュメントが見つかりません' });
    }
    
    const document = global.documents.get(id)!;
    res.json({ text: document.artifacts.text || '' });
    
  } catch (error) {
    console.error('テキスト取得エラー:', error);
    res.status(500).json({ error: 'テキスト取得中にエラーが発生しました' });
  }
});

// ドキュメントのエンティティ取得
app.get('/v1/documents/:id/entities', (req, res) => {
  try {
    const { id } = req.params;
    
    if (!global.documents || !global.documents.has(id)) {
      return res.status(404).json({ error: 'ドキュメントが見つかりません' });
    }
    
    const document = global.documents.get(id)!;
    res.json({ entities: document.artifacts.entities || {} });
    
  } catch (error) {
    console.error('エンティティ取得エラー:', error);
    res.status(500).json({ error: 'エンティティ取得中にエラーが発生しました' });
  }
});

// ドキュメントのページ取得
app.get('/v1/documents/:id/pages/:pageNum', (req, res) => {
  try {
    const { id, pageNum } = req.params;
    const pageIndex = parseInt(pageNum) - 1;
    
    if (!global.documents || !global.documents.has(id)) {
      return res.status(404).json({ error: 'ドキュメントが見つかりません' });
    }
    
    const document = global.documents.get(id)!;
    const pages = document.artifacts.pages || [];
    
    if (pageIndex < 0 || pageIndex >= pages.length) {
      return res.status(404).json({ error: 'ページが見つかりません' });
    }
    
    res.json({ page: pages[pageIndex] });
    
  } catch (error) {
    console.error('ページ取得エラー:', error);
    res.status(500).json({ error: 'ページ取得中にエラーが発生しました' });
  }
});

// 検索
app.get('/v1/search', (req, res) => {
  try {
    const { q: query, filters } = req.query;
    
    if (!global.documents) {
      return res.json({ results: [], total: 0 });
    }
    
    let results = Array.from(global.documents.values());
    
    // テキスト検索
    if (query) {
      const searchQuery = (query as string).toLowerCase();
      results = results.filter(doc => 
        doc.artifacts.text?.toLowerCase().includes(searchQuery) ||
        doc.meta.expo?.toLowerCase().includes(searchQuery) ||
        doc.meta.booth?.toLowerCase().includes(searchQuery)
      );
    }
    
    // フィルタリング
    if (filters) {
      const filterArray = Array.isArray(filters) ? filters : [filters];
      results = results.filter(doc => 
        filterArray.some(filter => 
          doc.tasks.includes(filter as string)
        )
      );
    }
    
    res.json({
      results: results.slice(0, 50), // 最大50件
      total: results.length
    });
    
  } catch (error) {
    console.error('検索エラー:', error);
    res.status(500).json({ error: '検索中にエラーが発生しました' });
  }
});

// ドキュメント再処理
app.post('/v1/documents/:id/reprocess', async (req, res) => {
  try {
    const { id } = req.params;
    const { tasks, options } = req.body;
    
    if (!global.documents || !global.documents.has(id)) {
      return res.status(404).json({ error: 'ドキュメントが見つかりません' });
    }
    
    const document = global.documents.get(id)!;
    const jobId = `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // 新しいジョブ作成
    const job: Job = {
      id: jobId,
      document_id: id,
      status: 'queued',
      progress: 0,
      tasks: tasks || document.tasks,
      created_at: new Date().toISOString(),
      artifacts: []
    };
    
    if (!global.jobs) global.jobs = new Map();
    global.jobs.set(jobId, job);
    
    // 非同期処理を開始
    processDocumentAsync(id, jobId, document.source, tasks || document.tasks, options);
    
    res.status(202).json({
      job_id: jobId,
      status: 'queued'
    });
    
  } catch (error) {
    console.error('再処理エラー:', error);
    res.status(500).json({ error: '再処理中にエラーが発生しました' });
  }
});

// 非同期ドキュメント処理関数
async function processDocumentAsync(documentId: string, jobId: string, source: any, tasks: string[], options: any) {
  try {
    if (!global.jobs) global.jobs = new Map();
    const job = global.jobs.get(jobId);
    if (!job) return;
    
    // ジョブステータスを更新
    job.status = 'processing';
    job.started_at = new Date().toISOString();
    job.progress = 10;
    global.jobs.set(jobId, job);
    
    let artifacts: any = {};
    
    // タスクごとに処理
    for (const task of tasks) {
      switch (task) {
        case 'ocr':
          if (source.type === 'file') {
            const ocrResult = await processOCRTask(source, options);
            artifacts.text = ocrResult.text;
            artifacts.entities = ocrResult.entities;
          }
          break;
          
        case 'web_clip':
          if (source.type === 'url') {
            const webClipResult = await processWebClipTask(source.url, options);
            artifacts.text = webClipResult.text;
            artifacts.entities = webClipResult.entities;
          }
          break;
          
        case 'pdf_analyze':
          if (source.type === 'file') {
            const pdfResult = await processPDFAnalyzeTask(source, options);
            artifacts.text = pdfResult.text;
            artifacts.pages = pdfResult.pages;
            artifacts.entities = pdfResult.entities;
          }
          break;
      }
      
      job.progress += 30;
      global.jobs.set(jobId, job);
    }
    
    // ドキュメントを更新
    if (!global.documents) global.documents = new Map();
    const document = global.documents.get(documentId);
    if (document) {
      document.artifacts = artifacts;
      document.status = 'completed';
      document.updated_at = new Date().toISOString();
      global.documents.set(documentId, document);
    }
    
    // ジョブ完了
    job.status = 'succeeded';
    job.progress = 100;
    job.completed_at = new Date().toISOString();
    job.artifacts = [
      { type: 'text', url: `/v1/documents/${documentId}/text` },
      { type: 'entities', url: `/v1/documents/${documentId}/entities` }
    ];
    global.jobs.set(jobId, job);
    
  } catch (error) {
    console.error('ドキュメント処理エラー:', error);
    
    // エラー処理
    if (!global.jobs) global.jobs = new Map();
    const job = global.jobs.get(jobId);
    if (job) {
      job.status = 'failed';
      job.error = error instanceof Error ? error.message : 'Unknown error';
      job.completed_at = new Date().toISOString();
      global.jobs.set(jobId, job);
    }
    
    if (!global.documents) global.documents = new Map();
    const document = global.documents.get(documentId);
    if (document) {
      document.status = 'failed';
      document.updated_at = new Date().toISOString();
      global.documents.set(documentId, document);
    }
  }
}

// ===== ワーカーシステム =====

// OCRワーカー（画像・スキャン）
async function processOCRTask(source: any, options: any) {
  try {
    console.log('OCRワーカー開始:', source.filename);
    
    // ファイルパスを構築
    const filePath = path.join(__dirname, '..', 'uploads', source.filename);
    
    // 画像のテキスト抽出
    const extractedText = await extractTextFromImage(filePath);
    
    // エンティティ抽出
    const entities = extractEntities(extractedText);
    
    // レイアウト分析
    const layout = analyzeLayout(extractedText);
    
    // タグ生成
    const tags = generateTags(entities, extractedText);
    
    return {
      text: extractedText,
      entities,
      layout,
      tags,
      metadata: {
        file_size: source.size,
        mime_type: source.mime_type,
        processing_time: Date.now()
      }
    };
  } catch (error) {
    console.error('OCRワーカーエラー:', error);
    throw error;
  }
}

// Webクリップワーカー（URL→HTML取得→本文抽出）
async function processWebClipTask(url: string, options: any) {
  try {
    console.log('Webクリップワーカー開始:', url);
    
    // URLからHTMLを取得（簡易実装）
    const response = await fetch(url);
    const html = await response.text();
    
    // HTMLから本文を抽出（簡易実装）
    const text = extractTextFromHTML(html);
    
    // エンティティ抽出
    const entities = extractEntities(text);
    
    // メタデータ抽出
    const metadata = extractWebMetadata(html);
    
    return {
      text,
      entities,
      metadata: {
        url,
        title: metadata.title,
        description: metadata.description,
        processing_time: Date.now()
      }
    };
  } catch (error) {
    console.error('Webクリップワーカーエラー:', error);
    throw error;
  }
}

// PDFワーカー（PDF→ページ分解→OCR/解析）
async function processPDFAnalyzeTask(source: any, options: any) {
  try {
    console.log('PDFワーカー開始:', source.filename);
    
    // ファイルパスを構築
    const filePath = path.join(__dirname, '..', 'uploads', source.filename);
    
    // PDF分析実行
    const analysisResult = await extractTextFromPDF(filePath, options?.enableOCR || false);
    
    // エンティティ抽出
    const entities = extractEntities(analysisResult);
    
    // ページ情報の解析
    const pages = parsePDFPages(analysisResult);
    
    return {
      text: analysisResult,
      entities,
      pages,
      metadata: {
        file_size: source.size,
        mime_type: source.mime_type,
        processing_time: Date.now()
      }
    };
  } catch (error) {
    console.error('PDFワーカーエラー:', error);
    throw error;
  }
}

// 共通処理関数
function extractTextFromHTML(html: string): string {
  // 簡易的なHTMLテキスト抽出
  return html
    .replace(/<script[^>]*>.*?<\/script>/gis, '')
    .replace(/<style[^>]*>.*?<\/style>/gis, '')
    .replace(/<[^>]*>/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function extractWebMetadata(html: string): { title: string; description: string } {
  const titleMatch = html.match(/<title[^>]*>(.*?)<\/title>/i);
  const descMatch = html.match(/<meta[^>]*name=["']description["'][^>]*content=["']([^"']*)["']/i);
  
  return {
    title: titleMatch ? titleMatch[1].trim() : '',
    description: descMatch ? descMatch[1].trim() : ''
  };
}

function parsePDFPages(text: string): any[] {
  // PDFのページ情報を解析（簡易実装）
  const pages = text.split('=== ページ');
  return pages.slice(1).map((page, index) => ({
    page_number: index + 1,
    text: page.replace(/^ \d+ ===\n/, '').trim(),
    word_count: page.split(/\s+/).length
  }));
}

app.listen(PORT, () => {
  console.log(`Insight-Box server running on http://localhost:${PORT}`);
});
